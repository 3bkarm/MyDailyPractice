## [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/?envType=daily-question&envId=2025-10-05)
```java
class Solution {
    private int n, m, targetX, targetY;
    private int[][] h;
    private boolean[][] vis, can;

    private int[] dx = new int[]{ 0, 0, -1, 1 };
    private int[] dy = new int[]{ -1, 1, 0, 0 };

    private boolean[][] check() {
        vis = new boolean[n][m];
        can = new boolean[n][m];
        Queue<int[]> q = new LinkedList<>();
        for (int y = 0; y < m; ++y) {
            vis[targetX][y] = true;
            can[targetX][y] = true;
            q.add(new int[]{ targetX, y });
        }
        for (int x = 0; x < n; ++x) {
            vis[x][targetY] = true;
            can[x][targetY] = true;
            q.add(new int[]{ x, targetY });
        }
        while ( !q.isEmpty() ) {
            int[] t = q.poll();
            int x = t[0], y = t[1];
            for (int move = 0, tox, toy; move < 4; ++move) {
                tox = x + dx[move];
                toy = y + dy[move];
                if (tox >= 0 && toy >= 0 && tox < n && toy < m && !vis[tox][toy] && h[tox][toy] >= h[x][y]) {
                    vis[tox][toy] = true;
                    can[tox][toy] = true;
                    q.add(new int[]{ tox, toy });
                }
            }
        }
        return can;
    }

    public List< List<Integer> > pacificAtlantic(int[][] heights) {
        n = heights.length;
        m = heights[0].length;
        h = heights;

        targetX = 0;
        targetY = 0;
        boolean[][] canPacific = check();

        targetX = n - 1;
        targetY = m - 1;
        boolean[][] canAtlantic = check();

        List< List<Integer> > ans = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (canPacific[i][j] && canAtlantic[i][j]) {
                    ans.add( List.of(i, j) );
                }
            }
        }

        return ans;
    }
}
```
