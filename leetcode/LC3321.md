## [Find X-Sum of All K-Long Subarrays II](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii?envType=daily-question&envId=2025-11-05)

```java
class Solution {
    private final static int limit = 100_000;
    private static int[] freq;

    static {
        freq = new int[limit];
    }

    private int n, x;
    private long sum;
    private int[] mp;
    private TreeSet<int[]> top, bottom;

    private TreeSet<int[]> initializeTreeSets() {
        return new TreeSet<>( (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return b[0] - a[0];
        } );
    }

    private int lowerBound(int value, int[] t) {
        int lo = 0, hi = n - 1, ans = -1;
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            if (t[mid] <= value) {
                lo = mid + 1;
                ans = mid;
            } else {
                hi = mid - 1;
            }
        }
        return ans;
    }

    private void compress(int[] nums) {
        mp = new int[n];
        int[] t = Arrays.copyOf(nums, n);
        Arrays.sort(t);
        for (int i = 0; i < n; ++i) {
            int x = lowerBound(nums[i], t);
            mp[x] = nums[i];
            nums[i] = x;
        }
    }

    private void remove(int value) {
        int[] t = new int[]{ freq[value], value };
        if ( top.contains(t) ) {
            sum -= 1l * freq[value] * mp[value];
            top.remove(t);
        } else {
            bottom.remove(t);
        }
    }

    private void add(int value) {
        bottom.add(new int[]{ freq[value], value });
    }

    private void fill() {
        while ( top.size() < x && !bottom.isEmpty() ) {
            int[] t = Arrays.copyOf(bottom.first(), 2);
            sum += 1l * t[0] * mp[ t[1] ];
            top.add(t);
            bottom.remove(t);
        }
    }

    private void adjust() {
        if ( top.size() < x || bottom.isEmpty() ) {
            return;
        }
        while ( (top.last()[0] < bottom.first()[0]) || (top.last()[0] == bottom.first()[0] && top.last()[1] < bottom.first()[1]) ) {
            int[] t = Arrays.copyOf(top.last(), 2);
            sum -= 1l * t[0] * mp[ t[1] ];
            bottom.add(t);
            top.remove(t);

            t = Arrays.copyOf(bottom.first(), 2);
            sum += 1l * t[0] * mp[ t[1] ];
            top.add(t);
            bottom.remove(t);
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        n = nums.length;
        this.x = x;
        sum = 0l;
        top = initializeTreeSets();
        bottom = initializeTreeSets();
        long[] ans = new long[n - k + 1];
        compress(nums);
        for (int r = 0, l = -k, p = -k + 1; r < n; ++r, ++l, ++p) {
            if (l >= 0) {
                remove(nums[l]);
                --freq[ nums[l] ];
                add(nums[l]);
            }
            remove(nums[r]);
            ++freq[ nums[r] ];
            add(nums[r]);
            fill();
            adjust();
            if (p >= 0) {
                ans[p] = sum;
            }
        }
        for (int i = 0; i < n; ++i) {
            freq[ nums[i] ] = 0;
        }
        return ans;
    }
}
```
